// Copyright 2019-2020 Intel Corporation
// SPDX-License-Identifier: Apache-2.0

#pragma once

#include "../common/Hit.ih"
#include "../common/Interval.ih"
#include "../sampler/Sampler.ih"
#include "math/box.ih"
#include "openvkl/iterator.isph"

/*
 * Intersect isosurfaces along the given ray using Newton-Raphson iteration.
 */
#define template_intersectSurfacesNewton(univary)                              \
  inline univary bool intersectSurfacesNewton(const Sampler *uniform sampler,  \
                                        const univary vec3f &origin,           \
                                        const univary vec3f &direction,        \
                                        const univary box1f &tRange,           \
                                        const uniform float step,              \
                                        const uniform int numValues,           \
                                        const float *uniform values,           \
                                        univary Hit &hit)                      \
  {                                                                            \
    /* our bracketing sample t-values will always be in multiples of `step`,   \
    to avoid artifacts / differences in hits between neighboring rays, or when \
    moving between macrocell boundaries, for example.                          \
                                                                               \
    note that the current approach here takes only one Newton iteration, so    \
    consistent bracketing is especially important for "smooth" results. */     \
    const univary int minTIndex = floor(tRange.lower / step);                  \
    const univary int maxTIndex = ceil(tRange.upper / step);                   \
                                                                               \
    univary float t0 = minTIndex * step;                                       \
    univary float sample0 =                                                    \
        sampler->computeSample_##univary(sampler, origin + t0 * direction);    \
                                                                               \
    univary float t;                                                           \
                                                                               \
    for (univary int i = minTIndex; i < maxTIndex; i++) {                      \
      t = (i + 1) * step;                                                      \
                                                                               \
      const univary float sample =                                             \
          sampler->computeSample_##univary(sampler, origin + t * direction);   \
                                                                               \
      univary float tHit    = inf;                                             \
      univary float epsilon = inf;                                             \
      univary float value   = inf;                                             \
                                                                               \
      if (!isnan(sample0 + sample) && (sample != sample0)) {                   \
        for (uniform int i = 0; i < numValues; i++) {                          \
          if ((values[i] - sample0) * (values[i] - sample) <= 0.f) {           \
            const univary float rcpSamp = 1.f / (sample - sample0);            \
            univary float tIso          = inf;                                 \
            if (!isnan(rcpSamp)) {                                             \
              tIso = t0 + (values[i] - sample0) * rcpSamp * (t - t0);          \
            }                                                                  \
                                                                               \
            if (tIso < tHit && tIso >= tRange.lower && tIso <= tRange.upper) { \
              tHit    = tIso;                                                  \
              value   = values[i];                                             \
              epsilon = step * 0.125f;                                         \
            }                                                                  \
          }                                                                    \
        }                                                                      \
                                                                               \
        if (tHit < inf) {                                                      \
          hit.t       = tHit;                                                  \
          hit.sample  = value;                                                 \
          hit.epsilon = epsilon;                                               \
          return true;                                                         \
        }                                                                      \
      }                                                                        \
                                                                               \
      t0      = t;                                                             \
      sample0 = sample;                                                        \
    }                                                                          \
                                                                               \
    return false;                                                              \
  }

template_intersectSurfacesNewton(uniform);
template_intersectSurfacesNewton(varying);
#undef template_intersectSurfacesNewton

/*
 * Intersect isosurfaces along the given ray using bisection method.
 */

#define template_intersectSurfacesBisection(univary)                            \
  inline univary float bisect(const Sampler *uniform sampler,                   \
                              const univary vec3f &origin,                      \
                              const univary vec3f &direction,                   \
                              univary float t0,                                 \
                              univary float sample0,                            \
                              univary float t,                                  \
                              univary float sample,                             \
                              uniform float isovalue,                           \
                              univary float tol,                                \
                              univary float &error)                             \
  {                                                                             \
    const uniform int maxIter = 10;                                             \
                                                                                \
    uniform int iter = 0;                                                       \
    univary float tMid;                                                         \
                                                                                \
    while (iter < maxIter) {                                                    \
      tMid = 0.5f * (t0 + t);                                                   \
                                                                                \
      error = 0.5f * (t - t0);                                                  \
                                                                                \
      if (error < tol) {                                                        \
        break;                                                                  \
      }                                                                         \
                                                                                \
      univary float sampleMid =                                                 \
          sampler->computeSample_##univary(sampler, origin + tMid * direction); \
                                                                                \
      /* sampling at boundaries between unstructured cells can rarely lead to   \
      NaN values (indicating outside of cell) due to numerical issues; in this  \
      case we know we have already bracketed an isovalue, so return the nearest \
      result */                                                                 \
      if (isnan(sampleMid)) {                                                   \
        if (abs(isovalue - sample0) < abs(isovalue - sample)) {                 \
          return t0;                                                            \
        } else {                                                                \
          return t;                                                             \
        }                                                                       \
      }                                                                         \
                                                                                \
      if (sampleMid == isovalue ||                                              \
          (isovalue - sample0) * (isovalue - sampleMid) < 0.f) {                \
        /* crossing in (t0, tMid) */                                            \
        t      = tMid;                                                          \
        sample = sampleMid;                                                     \
      } else if (sample == isovalue ||                                          \
                 (isovalue - sample) * (isovalue - sampleMid) < 0.f) {          \
        /* crossing in (tMid, t) */                                             \
        t0      = tMid;                                                         \
        sample0 = sampleMid;                                                    \
      } else {                                                                  \
        /* should never get here */                                             \
        print("bisect error\n");                                                \
        return inf;                                                             \
      }                                                                         \
                                                                                \
      iter++;                                                                   \
    }                                                                           \
                                                                                \
    return tMid;                                                                \
  }                                                                             \
                                                                                \
  inline univary bool intersectSurfacesBisection(                               \
      const Sampler *uniform sampler,                                           \
      const univary vec3f &origin,                                              \
      const univary vec3f &direction,                                           \
      const univary box1f &tRange,                                              \
      const univary float step,                                                 \
      const uniform int numValues,                                              \
      const float *uniform values,                                              \
      univary Hit &hit)                                                         \
  {                                                                             \
    univary float t0 = tRange.lower;                                            \
    univary float sample0 =                                                     \
        sampler->computeSample_##univary(sampler, origin + t0 * direction);     \
                                                                                \
    univary float t;                                                            \
                                                                                \
    while (t0 < tRange.upper) {                                                 \
      t = t0 + step;                                                            \
      const univary float sample =                                              \
          sampler->computeSample_##univary(sampler, origin + t * direction);    \
                                                                                \
      univary float tHit    = inf;                                              \
      univary float epsilon = inf;                                              \
      univary float value   = inf;                                              \
                                                                                \
      for (uniform int i = 0; i < numValues; i++) {                             \
        if (!isnan(sample0 + sample) &&                                         \
            (values[i] - sample0) * (values[i] - sample) < 0.f) {               \
          /* we have bracketed a crossing; bisect */                            \
          univary float error;                                                  \
          univary float tIso = bisect(sampler,                                  \
                                      origin,                                   \
                                      direction,                                \
                                      t0,                                       \
                                      sample0,                                  \
                                      t,                                        \
                                      sample,                                   \
                                      values[i],                                \
                                      0.01f * step,                             \
                                      error);                                   \
                                                                                \
          if (tIso < tHit && tIso <= tRange.upper) {                            \
            tHit    = tIso;                                                     \
            value   = values[i];                                                \
            epsilon = 0.125f * step;                                            \
          }                                                                     \
        }                                                                       \
      }                                                                         \
                                                                                \
      if (tHit < inf) {                                                         \
        hit.t       = tHit;                                                     \
        hit.sample  = value;                                                    \
        hit.epsilon = epsilon;                                                  \
        return true;                                                            \
      }                                                                         \
                                                                                \
      t0      = t;                                                              \
      sample0 = sample;                                                         \
    }                                                                           \
                                                                                \
    return false;                                                               \
  }

template_intersectSurfacesBisection(uniform);
template_intersectSurfacesBisection(varying);
#undef template_intersectSurfacesBisection
