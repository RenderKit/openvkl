// Copyright 2019-2020 Intel Corporation
// SPDX-License-Identifier: Apache-2.0

#pragma once

#include "math/box.ih"
#include "math/math.ih"
#include "math/vec.ih"
#include "openvkl/vdb.h"

struct DdaState
{
  // The level at which we iterate.
  uniform uint32 level;

  // The current ray parameter.
  float t;

  // The current index. This is always a value modulo the cell size
  // on the current level.
  int32 idx[3];

  float tNext[3];
  float tDelta[3];
  int32 idxDelta[3];
};

// -----------------------------------------------------------------------------
// Utilities.
// -----------------------------------------------------------------------------

/*
 * Returns -1 for negative v, 0 for 0, and 1 for positive v.
 */
inline int safe_sign(float v)
{
  return ((int)(0 < v)) - ((int)(v < 0));
}

inline vec3i safe_sign(const vec3f &v)
{
  return make_vec3i(safe_sign(v.x), safe_sign(v.y), safe_sign(v.z));
}

/*
 * Compute 1/v, returning infinity for 0.
 */
inline float safe_rcp(float v)
{
  return (v == -0) ? -inf : (v == 0) ? inf : rcp(v);
}

inline vec3f safe_rcp(const vec3f &v)
{
  return make_vec3f(safe_rcp(v.x), safe_rcp(v.y), safe_rcp(v.z));
}

/*
 * Intersect a set of three axis-aligned hyperplanes.
 */
inline vec3f intersect_planes(const vec3f &rayOrg,
                              const vec3f &rayInvDir,
                              const vec3f &planes)
{
  const float tx = (planes.x - rayOrg.x) * rayInvDir.x;
  const float ty = (planes.y - rayOrg.y) * rayInvDir.y;
  const float tz = (planes.z - rayOrg.z) * rayInvDir.z;

  // NaN will occur if the ray starts on a plane (planes-rayOrg == 0) but
  // is also fully contained in this plane (rayDir == 0 -> rayInvDir == inf).
  // We want to ignore such intersections.
  return make_vec3f(select(isnan(tx), inf, tx),
                    select(isnan(ty), inf, ty),
                    select(isnan(tz), inf, tz));
}

/*
 * Intersect a box.
 */
inline void intersect_box(const vec3f &rayOrg,
                          const vec3f &rayInvDir,
                          const vec3f &boxMin,
                          const vec3f &boxMax,
                          float &tEnter,
                          float &tExit)
{
  const vec3f pmins = intersect_planes(rayOrg, rayInvDir, boxMin);
  const vec3f pmaxs = intersect_planes(rayOrg, rayInvDir, boxMax);
  const vec3f mins  = min(pmins, pmaxs);
  const vec3f maxs  = max(pmins, pmaxs);
  tEnter            = max(mins.x, max(mins.y, mins.z));
  tExit             = min(maxs.x, min(maxs.y, maxs.z));
}

/*
 * Compare __vkl_vdb_map_domain_offset_to_voxel_uniform_*
 * in openvkl/vdb_topology.h.in.
 */
inline void clampOffsetToCell(
    int32 &x,
    int32 &y,
    int32 &z,
    uniform int32 resolution)  // ... of a single cell on the current level.
{
  // We may map a voxel coordinate to the origin of a voxel with resolution
  // logVoxelRes using this simple mask because resolutions are powers of two.
  assert(popcnt(resolution) == 1);
  const uniform int mask = ~((resolution)-1);
  x                      = x & mask;
  y                      = y & mask;
  z                      = z & mask;
}

inline void clampOffsetToCellVarying(
    int32 &x,
    int32 &y,
    int32 &z,
    int32 resolution)  // ... of a single cell on the current level.
{
  // We may map a voxel coordinate to the origin of a voxel with resolution
  // logVoxelRes using this simple mask because resolutions are powers of two.
  assert(popcnt(resolution) == 1);
  const int mask = ~((resolution)-1);
  x              = x & mask;
  y              = y & mask;
  z              = z & mask;
}

inline vec3i clampToCell(
    const vec3f &foffset,
    uniform int32 resolution)  // ... of a single cell on the current level.
{
  // Offsets are non-negative, but numerical errors might cause problems.
  vec3i offset = make_vec3i(((int)floor(max(foffset.x, 0))),
                            ((int)floor(max(foffset.y, 0))),
                            ((int)floor(max(foffset.z, 0))));
  clampOffsetToCell(offset.x, offset.y, offset.z, resolution);
  return offset;
}

/*
 * Initialize the dda state.
 */
inline void ddaInit(const vec3f &rayOrg,  // ray in index space.
                    const vec3f &rayDir,
                    const float &tMin,
                    uniform uint32 level,
                    varying DdaState &dda)
{
  const vec3f oo                 = rayOrg + tMin * rayDir;
  const vec3i sgn                = safe_sign(rayDir);
  const vec3f iDir               = safe_rcp(rayDir);
  const uniform int32 logCellRes = vklVdbLevelTotalLogRes(level + 1);
  const uniform int32 cellRes    = (1 << logCellRes);

  // Clamp the origin to a cell on this level, i.e., a multiple of the
  // cell resolution. This results in the index of the cell we are in.
  const vec3i idx = clampToCell(oo, cellRes);

  const vec3i sgnNonNegative =
      make_vec3i(((int)(sgn.x >= 0)), ((int)(sgn.y >= 0)), ((int)(sgn.z >= 0)));

  // Intersect the exiting plane to get the initial tNext for this level.
  const vec3f planes =
      make_vec3f(((float)(idx.x + cellRes * sgnNonNegative.x)),
                 ((float)(idx.y + cellRes * sgnNonNegative.y)),
                 ((float)(idx.z + cellRes * sgnNonNegative.z)));

  const vec3f tn = intersect_planes(rayOrg, iDir, planes);

  dda.t           = tMin;
  dda.level       = clamp(level, 0, VKL_VDB_NUM_LEVELS - 1);
  dda.idx[0]      = idx.x;
  dda.idx[1]      = idx.y;
  dda.idx[2]      = idx.z;
  dda.idxDelta[0] = sgn.x * cellRes;
  dda.idxDelta[1] = sgn.y * cellRes;
  dda.idxDelta[2] = sgn.z * cellRes;
  dda.tDelta[0]   = ((float)cellRes) * abs(iDir.x);
  dda.tDelta[1]   = ((float)cellRes) * abs(iDir.y);
  dda.tDelta[2]   = ((float)cellRes) * abs(iDir.z);
  dda.tNext[0]    = tn.x;
  dda.tNext[1]    = tn.y;
  dda.tNext[2]    = tn.z;
}

/*
 * Step once.
 */
inline void ddaStep(DdaState &dda)
{
  const float minT = min(min(dda.tNext[0], dda.tNext[1]), dda.tNext[2]);
  if (minT == dda.tNext[0]) {
    dda.t        = dda.tNext[0];
    dda.tNext[0] = dda.tNext[0] + dda.tDelta[0];
    dda.idx[0]   = dda.idx[0] + dda.idxDelta[0];
  } else if (minT == dda.tNext[1]) {
    dda.t        = dda.tNext[1];
    dda.tNext[1] = dda.tNext[1] + dda.tDelta[1];
    dda.idx[1]   = dda.idx[1] + dda.idxDelta[1];
  } else {
    dda.t        = dda.tNext[2];
    dda.tNext[2] = dda.tNext[2] + dda.tDelta[2];
    dda.idx[2]   = dda.idx[2] + dda.idxDelta[2];
  }
}
