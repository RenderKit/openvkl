// Copyright 2019-2021 Intel Corporation
// SPDX-License-Identifier: Apache-2.0

#pragma once

// ---------------------------------------------------------------------------
// CONSTANT leaf sampling.
// ---------------------------------------------------------------------------

/*
 * Sample a constant leaf at the given offset, assuming compact data.
 */
inline varying float VdbSampler_sampleConstantFloatLeafCompact(
    const uniform Data1D *varying leafPtr,
    const varying vec3ui &offset,
    uniform uint32 attributeIndex)
{
  const varying uint64 voxelIdx =
      __vkl_vdb_domain_offset_to_linear_varying_leaf(
          offset.x, offset.y, offset.z);

  assert(voxelIdx < ((varying uint64)1) << 32);
  const varying uint32 v32 = ((varying uint32)voxelIdx);
  return get_float_compact(&leafPtr[attributeIndex], v32);
}

/*
 * Sample a constant leaf at the given offset, assuming strided data.
 */
inline varying float VdbSampler_sampleConstantFloatLeafStrided(
    const uniform Data1D *varying leafPtr,
    const varying vec3ui &offset,
    uniform uint32 attributeIndex)
{
  const varying uint64 voxelIdx =
      __vkl_vdb_domain_offset_to_linear_varying_leaf(
          offset.x, offset.y, offset.z);

  assert(voxelIdx < ((varying uint64)1) << 32);
  const varying uint32 v32 = ((varying uint32)voxelIdx);
  return get_float_strided(&leafPtr[attributeIndex], v32);
}

/*
 * Special case: all lanes are sampling the same leaf.
 * This gives us the opportunity to use uniform array indices, at least if
 * all sample points are in the same voxel.
 */

/* assumes compact data */
inline varying float VdbSampler_sampleConstantFloatLeafCompact(
    const uniform Data1D *uniform leafPtr,
    const varying vec3ui &offset,
    uniform uint32 attributeIndex)
{
  const varying uint64 voxelIdx =
      __vkl_vdb_domain_offset_to_linear_varying_leaf(
          offset.x, offset.y, offset.z);

  assert(voxelIdx < ((varying uint64)1) << 32);
  const varying uint32 v32 = ((varying uint32)voxelIdx);
  uniform uint32 uv32;
  if (reduce_equal(v32, &uv32))
    return get_float_compact(leafPtr[attributeIndex], uv32);
  else
    return get_float_compact(leafPtr[attributeIndex], v32);
}

/* assumes strided data */
inline varying float VdbSampler_sampleConstantFloatLeafStrided(
    const uniform Data1D *uniform leafPtr,
    const varying vec3ui &offset,
    uniform uint32 attributeIndex)
{
  const varying uint64 voxelIdx =
      __vkl_vdb_domain_offset_to_linear_varying_leaf(
          offset.x, offset.y, offset.z);

  assert(voxelIdx < ((varying uint64)1) << 32);
  const varying uint32 v32 = ((varying uint32)voxelIdx);
  uniform uint32 uv32;
  if (reduce_equal(v32, &uv32))
    return get_float_strided(leafPtr[attributeIndex], uv32);
  else
    return get_float_strided(leafPtr[attributeIndex], v32);
}
