// Copyright 2020 Intel Corporation
// SPDX-License-Identifier: Apache-2.0

#pragma once

#include "common.isph"
#include "volume.isph"

struct Sampler;
typedef Sampler *uniform VKLSampler;

VKL_API void vklComputeSample4(const int *uniform valid,
                               VKLSampler sampler,
                               const varying struct vkl_vec3f *uniform
                                   objectCoordinates,
                               varying float *uniform samples,
                               uniform unsigned int attributeIndex,
                               const varying float *uniform time);

VKL_API void vklComputeSample8(const int *uniform valid,
                               VKLSampler sampler,
                               const varying struct vkl_vec3f *uniform
                                   objectCoordinates,
                               varying float *uniform samples,
                               uniform unsigned int attributeIndex,
                               const varying float *uniform time);

VKL_API void vklComputeSample16(const int *uniform valid,
                                VKLSampler sampler,
                                const varying struct vkl_vec3f *uniform
                                    objectCoordinates,
                                varying float *uniform samples,
                                uniform unsigned int attributeIndex,
                                const varying float *uniform time);

VKL_FORCEINLINE varying float vklComputeSampleV(
    VKLSampler sampler,
    const varying vkl_vec3f *uniform objectCoordinates,
    uniform unsigned int attributeIndex = 0,
    const varying float *uniform time = NULL)
{
  varying bool mask = __mask;
  unmasked
  {
    varying int imask = mask ? -1 : 0;
  }

  varying float samples;

  if (sizeof(varying float) == 16) {
    vklComputeSample4((uniform int *uniform) & imask,
                      sampler,
                      objectCoordinates,
                      &samples,
                      attributeIndex,
                      time);
  } else if (sizeof(varying float) == 32) {
    vklComputeSample8((uniform int *uniform) & imask,
                      sampler,
                      objectCoordinates,
                      &samples,
                      attributeIndex,
                      time);
  } else if (sizeof(varying float) == 64) {
    vklComputeSample16((uniform int *uniform) & imask,
                       sampler,
                       objectCoordinates,
                       &samples,
                       attributeIndex,
                       time);
  }

  return samples;
}

VKL_API void vklComputeGradient4(const int *uniform valid,
                                 VKLSampler sampler,
                                 const varying struct vkl_vec3f *uniform
                                     objectCoordinates,
                                 varying vkl_vec3f *uniform gradients,
                                 uniform unsigned int attributeIndex,
                                 const varying float *uniform time);

VKL_API void vklComputeGradient8(const int *uniform valid,
                                 VKLSampler sampler,
                                 const varying struct vkl_vec3f *uniform
                                     objectCoordinates,
                                 varying vkl_vec3f *uniform gradients,
                                 uniform unsigned int attributeIndex,
                                 const varying float *uniform time);

VKL_API void vklComputeGradient16(const int *uniform valid,
                                  VKLSampler sampler,
                                  const varying struct vkl_vec3f *uniform
                                      objectCoordinates,
                                  varying vkl_vec3f *uniform gradients,
                                  uniform unsigned int attributeIndex,
                                  const varying float *uniform time);

VKL_FORCEINLINE varying vkl_vec3f
vklComputeGradientV(VKLSampler sampler,
                    const varying vkl_vec3f *uniform objectCoordinates,
                    uniform unsigned int attributeIndex = 0,
                    const varying float *uniform time = NULL)
{
  varying bool mask = __mask;
  unmasked
  {
    varying int imask = mask ? -1 : 0;
  }

  varying vkl_vec3f gradients;

  if (sizeof(varying float) == 16) {
    vklComputeGradient4((uniform int *uniform) & imask,
                        sampler,
                        objectCoordinates,
                        &gradients,
                        attributeIndex,
                        time);
  } else if (sizeof(varying float) == 32) {
    vklComputeGradient8((uniform int *uniform) & imask,
                        sampler,
                        objectCoordinates,
                        &gradients,
                        attributeIndex,
                        time);
  } else if (sizeof(varying float) == 64) {
    vklComputeGradient16((uniform int *uniform) & imask,
                         sampler,
                         objectCoordinates,
                         &gradients,
                         attributeIndex,
                         time);
  }

  return gradients;
}

VKL_API void vklComputeSampleM4(const int *uniform valid,
                                VKLSampler sampler,
                                const varying struct vkl_vec3f *uniform
                                    objectCoordinates,
                                varying float *uniform samples,
                                uniform unsigned int M,
                                const unsigned int *uniform attributeIndices,
                                const varying float *uniform time);

VKL_API void vklComputeSampleM8(const int *uniform valid,
                                VKLSampler sampler,
                                const varying struct vkl_vec3f *uniform
                                    objectCoordinates,
                                varying float *uniform samples,
                                uniform unsigned int M,
                                const unsigned int *uniform attributeIndices,
                                const varying float *uniform time);

VKL_API void vklComputeSampleM16(const int *uniform valid,
                                 VKLSampler sampler,
                                 const varying struct vkl_vec3f *uniform
                                     objectCoordinates,
                                 varying float *uniform samples,
                                 uniform unsigned int M,
                                 const unsigned int *uniform attributeIndices,
                                 const varying float *uniform time);

VKL_FORCEINLINE void vklComputeSampleMV(
    VKLSampler sampler,
    const varying vkl_vec3f *uniform objectCoordinates,
    varying float *uniform samples,
    uniform unsigned int M,
    const unsigned int *uniform attributeIndices,
    const varying float *uniform time = NULL)
{
  varying bool mask = __mask;
  unmasked
  {
    varying int imask = mask ? -1 : 0;
  }

  if (sizeof(varying float) == 16) {
    vklComputeSampleM4((uniform int *uniform) & imask,
                       sampler,
                       objectCoordinates,
                       samples,
                       M,
                       attributeIndices,
                       time);
  } else if (sizeof(varying float) == 32) {
    vklComputeSampleM8((uniform int *uniform) & imask,
                       sampler,
                       objectCoordinates,
                       samples,
                       M,
                       attributeIndices,
                       time);
  } else if (sizeof(varying float) == 64) {
    vklComputeSampleM16((uniform int *uniform) & imask,
                        sampler,
                        objectCoordinates,
                        samples,
                        M,
                        attributeIndices,
                        time);
  }
}
